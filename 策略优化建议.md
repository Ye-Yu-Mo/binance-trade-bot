# 交易策略优化建议

## 当前策略分析

### 核心逻辑（Ratio-based贪心算法）
```python
# 当前策略的核心思想：
1. 计算当前币对其他所有币的价格比率
2. 与历史比率对比，找出ratio增长最大的币
3. 如果增长超过阈值（考虑手续费），就跳转
```

### 当前策略的问题

#### 1. 🔴 过度交易（频繁跳转）
**问题：**
- 每1-5秒检查一次，只要ratio > 0就跳转
- 可能在价格小幅波动时频繁交易
- 手续费侵蚀利润（每次交易0.075% * 2 = 0.15%）

**数据：**
```
假设每天交易10次：
- 年交易次数：3650次
- 手续费成本：3650 * 0.15% = 5.475倍本金！
```

#### 2. 🔴 没有止损机制
**问题：**
- 如果某个币持续下跌，没有止损保护
- 可能陷入"死币"困境

**案例：**
```
持有币A，跌幅-50%
→ 因为ratio计算基于历史，可能认为"已经够便宜"
→ 继续持有或买入更多
→ 如果是真的崩盘，损失惨重
```

#### 3. 🟡 忽略市场趋势
**问题：**
- 只看ratio，不看整体市场状态
- 牛市/熊市应采用不同策略

**改进：**
```python
# 应该判断市场状态
if is_bull_market():
    # 激进策略：追涨
    scout_margin = 0.5%
else:
    # 保守策略：持稳定币
    scout_margin = 1.5%
```

#### 4. 🟡 没有资金管理
**问题：**
- 全仓单币，风险集中
- 没有分散投资

#### 5. 🟡 ratio计算的局限性
**问题：**
```python
# 当前计算方式
ratio = current_price / optional_price
comparison = ratio - historical_ratio

# 问题：只看相对价格，不考虑：
- 成交量（流动性）
- 波动率（风险）
- 趋势方向（动量）
```

---

## 优化方案

### 🎯 方案1：减少交易频率（立即可用）

**修改配置文件 user.cfg：**
```ini
# 原配置
scout_margin=0.8          # 最小利润0.8%
scout_sleep_time=1        # 每1秒扫描

# 优化配置
scout_margin=2.0          # 提高到2%，覆盖双向手续费
scout_sleep_time=60       # 改为60秒，减少无意义扫描
```

**预期效果：**
- 交易次数减少70%+
- 手续费大幅降低
- 只在真正有利可图时交易

---

### 🎯 方案2：添加冷却时间（简单）

创建新策略 `conservative_strategy.py`：

```python
from binance_trade_bot.auto_trader import AutoTrader
from datetime import datetime, timedelta

class Strategy(AutoTrader):
    def initialize(self):
        super().initialize()
        self.initialize_current_coin()
        self.last_trade_time = datetime.now()
        self.cooldown_minutes = 60  # 1小时冷却

    def scout(self):
        # 检查冷却时间
        time_since_trade = (datetime.now() - self.last_trade_time).total_seconds() / 60
        if time_since_trade < self.cooldown_minutes:
            return  # 还在冷却期，跳过

        current_coin = self.db.get_current_coin()
        current_coin_price = self.manager.get_ticker_price(
            current_coin + self.config.BRIDGE
        )

        if current_coin_price is None:
            return

        # 执行原有逻辑
        self._jump_to_best_coin(current_coin, current_coin_price)
        self.last_trade_time = datetime.now()  # 更新交易时间
```

**配置：**
```ini
strategy=conservative
```

---

### 🎯 方案3：添加趋势过滤（中等难度）

创建 `trend_following_strategy.py`：

```python
from binance_trade_bot.auto_trader import AutoTrader
from collections import deque

class Strategy(AutoTrader):
    def initialize(self):
        super().initialize()
        self.initialize_current_coin()
        self.price_history = {}  # 价格历史
        self.ma_period = 20  # 移动平均周期

    def get_trend(self, coin_pair):
        """
        计算趋势：
        返回 1 (上涨), -1 (下跌), 0 (震荡)
        """
        if coin_pair not in self.price_history:
            self.price_history[coin_pair] = deque(maxlen=self.ma_period)

        prices = self.price_history[coin_pair]
        if len(prices) < self.ma_period:
            return 0  # 数据不足

        ma = sum(prices) / len(prices)
        current = prices[-1]

        if current > ma * 1.02:  # 高于均线2%
            return 1
        elif current < ma * 0.98:  # 低于均线2%
            return -1
        else:
            return 0

    def scout(self):
        current_coin = self.db.get_current_coin()
        coin_pair = current_coin + self.config.BRIDGE
        current_price = self.manager.get_ticker_price(coin_pair)

        if current_price is None:
            return

        # 更新价格历史
        if coin_pair not in self.price_history:
            self.price_history[coin_pair] = deque(maxlen=self.ma_period)
        self.price_history[coin_pair].append(current_price)

        # 判断趋势
        trend = self.get_trend(coin_pair)

        # 如果当前币种下跌趋势，才考虑跳转
        if trend == -1:
            self._jump_to_best_coin(current_coin, current_price)
        # 上涨趋势：持有
        # 震荡：持有
```

---

### 🎯 方案4：添加止损和止盈（推荐）

创建 `risk_managed_strategy.py`：

```python
from binance_trade_bot.auto_trader import AutoTrader
from datetime import datetime

class Strategy(AutoTrader):
    def initialize(self):
        super().initialize()
        self.initialize_current_coin()
        self.entry_prices = {}  # 记录买入价格
        self.stop_loss_pct = 5.0  # 止损5%
        self.take_profit_pct = 15.0  # 止盈15%

    def scout(self):
        current_coin = self.db.get_current_coin()
        coin_pair = current_coin + self.config.BRIDGE
        current_price = self.manager.get_ticker_price(coin_pair)

        if current_price is None:
            return

        # 记录入场价格（如果还没记录）
        if current_coin.symbol not in self.entry_prices:
            self.entry_prices[current_coin.symbol] = current_price
            self.logger.info(f"记录 {current_coin} 入场价格: {current_price}")

        entry_price = self.entry_prices[current_coin.symbol]

        # 计算盈亏百分比
        pnl_pct = (current_price - entry_price) / entry_price * 100

        # 止损检查
        if pnl_pct <= -self.stop_loss_pct:
            self.logger.info(
                f"触发止损！{current_coin} 亏损 {pnl_pct:.2f}%，"
                f"入场价 {entry_price}，当前价 {current_price}"
            )
            # 强制卖出，换回USDT
            self.manager.sell_alt(current_coin, self.config.BRIDGE)
            del self.entry_prices[current_coin.symbol]
            return

        # 止盈检查
        if pnl_pct >= self.take_profit_pct:
            self.logger.info(
                f"触发止盈！{current_coin} 盈利 {pnl_pct:.2f}%，"
                f"入场价 {entry_price}，当前价 {current_price}"
            )
            # 正常跳转逻辑
            self._jump_to_best_coin(current_coin, current_price)
            del self.entry_prices[current_coin.symbol]
            return

        # 正常侦察
        self._jump_to_best_coin(current_coin, current_price)

    def transaction_through_bridge(self, pair):
        """
        重写交易方法，记录新的入场价格
        """
        super().transaction_through_bridge(pair)

        # 记录新币种的入场价格
        new_coin_pair = pair.to_coin + self.config.BRIDGE
        new_price = self.manager.get_ticker_price(new_coin_pair)
        if new_price:
            self.entry_prices[pair.to_coin.symbol] = new_price
            self.logger.info(f"记录 {pair.to_coin} 新入场价格: {new_price}")
```

**配置：**
```ini
strategy=risk_managed
scout_margin=2.0
scout_sleep_time=60
```

---

### 🎯 方案5：多币种+仓位管理（高级）

创建 `portfolio_strategy.py`：

```python
from binance_trade_bot.auto_trader import AutoTrader

class Strategy(AutoTrader):
    """
    投资组合策略：同时持有多个币种，分散风险
    """
    def initialize(self):
        super().initialize()
        self.max_positions = 5  # 最多持有5个币种
        self.position_size_pct = 20  # 每个仓位20%

    def scout(self):
        """
        扫描所有有余额的币种
        """
        bridge_balance = self.manager.get_currency_balance(self.config.BRIDGE.symbol)
        total_value = self.calculate_total_value()

        # 遍历所有币种
        for coin in self.db.get_coins():
            balance = self.manager.get_currency_balance(coin.symbol)

            # 如果有余额，检查是否需要卖出
            if balance > 0:
                self.check_sell_signal(coin, balance)

        # 检查是否可以买入新币种
        if bridge_balance > total_value * 0.1:  # 有超过10%的USDT
            self.check_buy_signal(bridge_balance, total_value)

    def check_sell_signal(self, coin, balance):
        """检查卖出信号"""
        coin_price = self.manager.get_ticker_price(coin + self.config.BRIDGE)
        if coin_price is None:
            return

        ratio_dict = self._get_ratios(coin, coin_price)
        # 如果所有ratio都是负数，说明这个币相对弱势
        if all(v < -2.0 for v in ratio_dict.values()):  # 弱于其他币2%
            self.logger.info(f"{coin} 相对弱势，卖出")
            self.manager.sell_alt(coin, self.config.BRIDGE)

    def check_buy_signal(self, bridge_balance, total_value):
        """检查买入信号"""
        # 找出最强势的币种
        best_coin = None
        best_ratio = -999

        for coin in self.db.get_coins():
            price = self.manager.get_ticker_price(coin + self.config.BRIDGE)
            if price is None:
                continue

            ratio_dict = self._get_ratios(coin, price)
            avg_ratio = sum(ratio_dict.values()) / len(ratio_dict) if ratio_dict else -999

            if avg_ratio > best_ratio:
                best_ratio = avg_ratio
                best_coin = coin

        # 如果找到强势币且ratio > 阈值
        if best_coin and best_ratio > 2.0:
            # 计算买入金额（仓位管理）
            target_position_value = total_value * (self.position_size_pct / 100)
            current_positions = self.count_positions()

            if current_positions < self.max_positions:
                self.logger.info(
                    f"买入 {best_coin}，目标仓位价值: {target_position_value} USDT"
                )
                self.manager.buy_alt(best_coin, self.config.BRIDGE)

    def calculate_total_value(self):
        """计算总资产价值（USDT计价）"""
        total = self.manager.get_currency_balance(self.config.BRIDGE.symbol)
        for coin in self.db.get_coins():
            balance = self.manager.get_currency_balance(coin.symbol)
            if balance > 0:
                price = self.manager.get_ticker_price(coin + self.config.BRIDGE)
                if price:
                    total += balance * price
        return total

    def count_positions(self):
        """统计当前持仓数量"""
        count = 0
        for coin in self.db.get_coins():
            balance = self.manager.get_currency_balance(coin.symbol)
            if balance > 0:
                count += 1
        return count
```

---

## 推荐实施路线

### 阶段1：立即优化（0代码）
```ini
# 修改 user.cfg
scout_margin=2.0          # 提高利润阈值
scout_sleep_time=60       # 减少扫描频率
```

### 阶段2：回测对比（1天）
1. 用当前策略回测：`python backtest_doge_1year.py`
2. 修改配置后回测，对比收益

### 阶段3：实施优化策略（1周）
1. 实施方案2（冷却时间）- 最简单有效
2. 实施方案4（止损止盈）- 风险控制

### 阶段4：高级优化（按需）
- 根据回测结果决定是否实施方案3、5

---

## 性能预测

### 当前策略问题
```
假设初始资金: 100 USDT
年交易次数: 3000次
手续费率: 0.15% * 3000 = 450%
即使策略收益+200%，扣除手续费后可能亏损
```

### 优化后（方案2 + 方案4）
```
年交易次数: 100次（减少97%）
手续费率: 0.15% * 100 = 15%
策略收益: +150%（止损保护下跌，止盈锁定利润）
净收益: +135%
```

---

## 总结

### 最紧迫的优化（按优先级）
1. ⚠️  **减少交易频率**（立即修改配置）
2. ⚠️  **添加冷却时间**（方案2）
3. 🔴 **添加止损止盈**（方案4）
4. 🟡 趋势过滤（方案3）
5. 🟢 多币种分散（方案5）

### 快速开始
```bash
# 1. 立即修改配置
vim user.cfg
# 设置 scout_margin=2.0 和 scout_sleep_time=60

# 2. 复制风险管理策略
cp 上面的risk_managed_strategy.py binance_trade_bot/strategies/

# 3. 修改配置启用
# user.cfg 中设置 strategy=risk_managed

# 4. 回测验证
python backtest_doge_1year.py
```

现在就开始优化吧！每一个改进都会显著提升收益率。
